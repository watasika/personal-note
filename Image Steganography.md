# 基于LSB算法和DCT算法的图像隐写术

## 概念综述

### 图像隐写术（Image Steganography）

​	隐写术是将信息隐藏在另一条消息或实物中以避免被发现的一种方法。隐写术可用于隐藏几乎任何类型的数字内容，包括文本、图像、视频或音频内容。隐藏的数据可以在目标位置处被提取出来。

> **隐写**和**数字水印**都是信息隐藏的技术，但它们的应用领域、目的和实现方式有一些不同：
>
> 前者作为信息隐藏和加密，且需要保持外观或内容的一致性；后者作为版权保护和内容认证，需要能抵抗些可能导致内容变形的操作，如压缩、裁剪、旋转等。
>

### LSB算法

​	早期的隐写算法，是一种基于图片最低有效位修改并储存信息的隐写方法。利用人眼对于色彩差异的不敏感性，将秘密信息通过一定的嵌入方法放入图片的**最低有效位**。

1. 基本原理

   ​	在png图片的存储中，每个像素都是由RGB三原色组成，比如css中用十六进制定义颜色：#FFFFFF。即红绿蓝各为FF。每个十六进制转为二进制是8bit，即(11111111)有256种颜色，一共包含256的三次方个颜色，即16777216中颜色，人类的眼睛可以区分约1,000万种不同的颜色，剩下无法区分的颜色就有6777216种。如果修改最后一位，是不影响颜色以及图片显示的。

![最低有效位隐写](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151121362.png)

2. 深入了解

   ​	因为灰度图是以单通道格式存储像素的，所以我们以灰度化的图像作为简单分析。若某个像素的值为78，其二进制为`01001110`，从左到右位权依次降低，左边为最高有效位(MSB)，右边为最低有效位(LSB)。把一张图的每个像素上相同位权抽取组成一个平面，即图的位平面。

   ![位平面](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151121093.jpg)

   以著名的lena图为例，下面是各个位平面图，从左到右上到下，位平面依次降低，右下方为最低位平面

   ![最低位嵌入](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151121407.jpg)

   可以看到，位平面越高包含的原图像信息越多，对图像的灰度值贡献最大，相邻比特关联性越强，位平面越低则反之。在最低位平面上几乎不包含图像信息了，呈现出随机的噪点，因此可以在此处写入隐藏信息。

4. 程序实现

   ![image-20240212224101556](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151121388.png)
   要读取信息时，获取图片像素最后一位，并转二进制为字符信息。

5. 演变

   LSB还有一种变化形式LSB匹配(LSB matching, 简称LSBM)。二者之间的差距在于：LSB对于最低有效位进行的是替换操作；LSBM采用的则是随机±1原则, 采用三元伴随式矩阵编码(syndrome-trellis codes, 简称STC)嵌入秘密信息。

6. 缺点

   - 基本嵌入方法给出了隐写算法的优化的基础，然而这些方法只保持了载体的低阶的特征分布，**难以构造合适的方法来保持载体的高阶特征分布**。即鲁棒性较差，当图像遇到信号处理，如加噪声、有损压缩等，嵌入的信息可能会被损坏。
   - 应用LSB算法的图像格式需为位图形式, 即图像不能经过压缩, 所以LSB算法多应用于PNG、BMP等**空域**图像中。

### 空域和频域

​	二维空间的自变量(x,y)视为一个点，图像则为二维空间中矩形区域的离散函数f(x,y)，显而易见可以通过某些数学方法得到某属性(特指灰度)的幅值频谱图。

空间域（spatial domain）：对于空间域的[图像处理](https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/294902?fr=ge_ala)主要是对像元[灰度值](https://baike.baidu.com/item/%E7%81%B0%E5%BA%A6%E5%80%BC/10259111?fr=ge_ala)的改变，其位置不变。可以简单理解为图像平面所在的二维平面。例子：PNG、BMP等位图。

频率域（spatial frequency domain）：图像像元的灰度值随位置变化的空间频率。频率域处理主要用于边缘增强、图像锐化、图像平滑等处理和分析中。例子：JPEG等压缩图像。

> 空间域与频率域可互相转换。通常由[傅里叶变换](https://baike.baidu.com/item/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/7119029)等方法完成。
>
> ![图像空域频域转换的图像结果](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151121080.jpg)

### DCT算法

![img](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151121010.png)

需要说明的是，DCT算法和LSB算法并非指具体某一种算法，而是提出思想，它代表了一系列算法的特征。因此，DCT算法也可以基于LSB算法的思想来做，如Jsteg算法等

> DCT即离散余弦变换，是在DFT(Discrete Fourier Transform 离散傅里叶变换)的基础上推导出来的，实际上它也是一种将图像从空域转换为频域的方法

1. 注意事项

   ​	由于JPEG图像进行编码时，涉及到**DCT变换**和**量化**，它们都是一个减少精度的有损过程，如果隐秘算法选择在量化前嵌入隐秘信息，那么量化之后很可能导致信息的丢失，提取时则会失真。所以现在大多数隐写术都是放在图像压缩量化之后，将信息放在DCT系数的最低比特位上，获得的新的DCT系数之后进行**熵编码**，而熵编码是无损的

2.  熵编码

   **熵的概念**：取自物理热力学概念，是体系混乱程度的度量。

   **信息熵的概念**：代表信息中排除了冗余后的平均信息量。

   **熵编码的概念**：在信息熵的极限范围内进行编码。比如信息熵算出来是3bit/字符，用4bit/字符来编码就是熵编码，用2bit/字符来编码就不叫熵编码。是一种为了保证不失真的无损压缩编码。

   **常见的熵编码**：霍夫曼编码(Huffman)、算术编码等。

3. 嵌入流程

   ![JPEG熵编码嵌入流程](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151121707.png)

   ​	对载体图像数据进行熵解码，获得量化后的DCT系数 -> 按照隐密术的规则和原理，将对应的秘密信息嵌入到DCT系数之上 -> 对获得的新的DCT系数再次进行熵编码，保存之后得到的就是载有秘密信息的隐密图像

4. 为什么要先进行熵解码？

   ​	DCT隐写是针对JPEG等频域变化图像的隐写术，那么先了解下JPEG图像的构成：**SQI(文件头)+APP0(图像识别信息 JFIF应用资料块)+DQT(定义量化表)+SOF0(图像基本信息 帧开始)+DHT(定义HUFFMAN表)**+DRI(定义重新开始间隔)+**SOS扫描开始+EOI(文件尾)**

   >  加粗字体为必须具有，反之。

   ![JPEG图片结构](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151121731.jpg)

   ​	JPEG压缩过程：颜色空间转换(RGB转YUV) -> 离散余弦变换(DCT) -> 量化(通过除以一个量化矩阵来降低更多的精度) -> 编码(使用霍夫曼(HUFFMAN)编码对量化后的DCT系数进行编码，以减小存储空间)

   ![JPG图片编码解码完整过程](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151122665.jpg)

   ​	可以看到JPEG图片是先进行了一次熵编码(霍夫曼编码)，所以我们操作时按道理需要先解码，解码的依据就是图片中自带的**DHT**。同理，量化也是差不多的操作。

   ​	图中在量化之后进行了还进行了一步Z字排列，目的是为了使系数排列成一维。DC系数是最重要的变量，它包含了很多关于原始图像的信息，代表着图像的大致走向和平坦程度等低频信息。而AC系数则是高频信息，包含了边界、细节等信息。所以改变AC系数相较于改变DC系数更加隐秘。

   ​	但由于JavaScript中对于像素级操作一般用canvas，而canvas自带图片的编解码过程，所以我们应该可以通过canvas直接解码原图拿到RGB数据，然后自己写编码过程，将加密信息放在DCT系数矩阵等上面，最后得到加密后的jpg图像。

5. 常见的DCT隐写算法

   - Jsteg隐密算法

     原理：使用JPEG图像量化后的DCT系数的最低比特位来承载秘密信息且要求不可以修改原始数值为±1或者0的系数。基本跟上述嵌入过程是一样的。

     优点：嵌入容量大、简单易实现

     弊端：可以被卡方分析方法分析出来

   - Outguess隐密算法

     原理：基本跟Jsteg算法一样，但为了保持隐密图像与原始图像的DCT特征不变，其余未被修改过的DCT系数会被修改以消除在嵌入过程中造成的统计特征的变化，使得DCT系数直方图保持原始的特征不变。

     优点：可以抵抗卡方检测

     缺点：会对图像的块边界的连续性造成影响，而且秘密信息越多越明显

     > 为了克服缺点产生了Outguss0.2版本的，不赘述

   - F系列隐密算法

     F3：也是将原始图像的AC系数中最低的一个位平面“替换”为要隐藏的秘密信息。遵循以下规则：

     - 每个非零的DCT系数隐藏1bit秘密信息

     - 秘密信息bit为0，当前DCT系数为±1时，将当前DCT系数赋0，跳过不嵌入。读取下一个DCT系数重新嵌入

     - 当秘密信息bit和当前DCT系数最低有效位相同时，不做改变；当秘密信息bit和当前DCT系数最低有效位不同时，将当前DCT系数的绝对值减一，符号保持相同复制给当前DCT系数

     F4：基于F3，在原有的基础上区分正值和负值的DCT系数， DCT系数是正值的情况下，系数的最低比特位与信息bit相同则不改变，不同的话则绝对值减1；当DCT系数是负值的话，规则相反。一定程度上保持了DCT直方图的特征
     
     F5：基于F4，使用了混洗技术，为的是将秘密信息随机的分布在整个图像之中，避免局部嵌入造成的显著影响。关键技术：矩阵编码(Hamming LSB 汉明阵编码)。
   
   

###近期的图像隐写分类

![image-20240212215741129](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151122484.png)

近期的图像隐写朝着深度学习方向发展。基于深度学习的图像隐写，与传统的编码式隐写有着不同的本质，所以它具有一些特点：

- 对抗网络学习可以使得隐写数据抗干扰能力提升
- 过拟合和欠拟合的特性使得参数和精度问题难以解决
- 多模型融合可以作为未来的实现方向
- 深度学习天生自带自适应，可以从容量、保密性等参数中取得局部最优解，甚至是多解

## 实际操作

### LSB加密详细过程

![image-20240218110949459](https://cdn.jsdelivr.net/gh/watasika/image-upload/blog-image/202404151122641.png)

> 解密反之，由于LSB能隐写的内容量很多，只要原图能装下，同理可以加密图像，甚至视频。



## 杂谈

### 对于tailwind的运用

1. 对于个别样式或者一些受外部库影响的html节点，以它自带的预设方案很难做到面面俱到，应该是需要配合Unocss这样的插件实现更多扩展
2. 上手曲线没有那么平滑，实际使用过程中，受先入为主的影响，第一时间总是会写原生css
3. 在一个节点内使用很多个预设class时，会显得十分臃肿，且不明所以，维护起来是有点难度的

### 对于nestjs的运用

1. 是一个很好用且易于理解的js后端库
2. 文档提供的内容十分有限，对一些api的描述是以业务为导向来整理的
3. 与其生态有关的插件通常需要定制化，如sequelize，在nestjs中需要使用插件库@nestjs/sequelize，对其中的一些用法做了封装，却没有在文档中体现出来。总之生态还有待完善

## 技术栈

### 前端

- Javascript
- TypeScript
- Vue3
- Element Plus
- Pinia
- Vite
- Vue Router
- Axios
- tailwind

### 后端

- nodejs（包含js和ts）
- nestjs
- jwt
- mysql8
- sequelize
